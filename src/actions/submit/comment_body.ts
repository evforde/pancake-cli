import { TContext } from '../../lib/context';
import { TBranchPRInfo } from '../../lib/engine/metadata_ref';

export interface PR extends Required<Pick<TBranchPRInfo, 'number' | 'base'>> {
  ref: string;
}

type Ref = PR['ref'];
type Trunk = TContext['engine']['trunk'];
type Tree = Record<Ref | Trunk, Array<PR | Pick<PR, 'base' | 'ref'>>>;
type Reverse = Record<Ref, Ref | Trunk>;

abstract class StackCommentBodyBase {
  protected tree: Tree;
  protected reverse: Reverse;
  protected prsByBranchName: Record<Ref, PR | Pick<PR, 'base' | 'ref'>>;
  protected constructor(protected context: TContext, prs: Array<PR>) {
    this.tree = { [context.engine.trunk]: [] };
    this.reverse = {};
    this.prsByBranchName = {};

    // Populate tree with PR info
    for (const pr of prs) {
      this.addBranchToTree(pr);
    }

    // Fill the remaining path to trunk if necessary
    for (const base of Object.keys(this.tree)) {
      this.findRouteToTrunk(base);
    }
  }

  private addBranchToTree(pr: PR | Pick<PR, 'base' | 'ref'>) {
    const deps = this.tree[pr.base];
    this.tree[pr.base] = deps ? [...deps, pr] : [pr];
    this.tree[pr.ref] = this.tree[pr.ref] ?? [];
    this.reverse[pr.ref] = pr.base;
    this.prsByBranchName[pr.ref] = pr;
  }

  private findRouteToTrunk(base: string): void {
    if (base === this.context.engine.trunk) {
      return;
    }

    if (base in this.reverse) {
      this.findRouteToTrunk(this.reverse[base]);
      return;
    }

    const pr = this.context.engine.getPrInfo(base);

    // Add PR to tree and continue iterating to trunk
    if (pr && pr.base && pr.number) {
      this.addBranchToTree({
        base: pr.base,
        number: pr.number,
        ref: base,
      });

      this.findRouteToTrunk(this.reverse[base]);
      return;
    }

    // If we don't have a PR, look up general branch info
    const parent = this.context.engine.getParent(base);
    if (parent) {
      this.addBranchToTree({ base: parent, ref: base });

      this.findRouteToTrunk(this.reverse[base]);
      return;
    }
  }

  protected buildTreeComment(currentPr: PR): string[] {
    const lines = [];
    const trunk = this.context.engine.trunk;

    const owner = this.context.repoConfig.getRepoOwner();
    const repo = this.context.repoConfig.getRepoName();

    const buildShortLine = (pr: PR | Pick<PR, 'base' | 'ref'>) => {
      if ('number' in pr) {
        return `[#${pr.number}](https://github.com/${owner}/${repo}/pull/${pr.number}) <a href="https://app.graphite.dev/github/pr/${owner}/${repo}/${pr.number}?utm_source=stack-comment-icon" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a>`;
      }
      return `Branch _${pr.ref}_`;
    };
    const buildLine = (
      pr: PR | Pick<PR, 'base' | 'ref'>,
      children: Array<PR | Pick<PR, 'base' | 'ref'>>
    ) => {
      if ('number' in pr) {
        let line = `**#${pr.number}** <a href="https://app.graphite.dev/github/pr/${owner}/${repo}/${pr.number}?utm_source=stack-comment-icon" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a>`;
        if (children.length > 1) {
          // If multiple children, add a line for all the children and stop traversing the tree.
          line += ` Dependent PRs: (${children
            .map((pr) => buildShortLine(pr))
            .join(', ')})`;
        }
        if (currentPr?.number === pr.number) {
          line += ' ðŸ‘ˆ';
        }
        return line;
      }
      return `Branch _${pr.ref}_`;
    };

    // Explore up the tree from the current PR
    let current: PR | Pick<PR, 'base' | 'ref'> = currentPr;
    while (current) {
      const children: Array<PR | Pick<PR, 'base' | 'ref'>> =
        this.tree[current.ref];
      lines.unshift(buildLine(current, children));
      if (children.length > 1) {
        // If multiple children, stop traversing the tree since we don't know which branch to follow.
        break;
      }
      current = children[0];
    }

    // Explore down the tree from the current PR to the trunk branch
    let currentRef = this.reverse[currentPr.ref];
    while (currentRef !== trunk) {
      const pr: PR | Pick<PR, 'base' | 'ref'> =
        this.prsByBranchName[currentRef];
      const childrenOfPr: Array<PR | Pick<PR, 'base' | 'ref'>> =
        this.tree[currentRef];
      lines.push(buildLine(pr, childrenOfPr));
      currentRef = this.reverse[currentRef];
    }
    lines.push(`\`${trunk}\``);

    return [
      ...lines.map((l) => `* ${l}`),
      '',
      'This comment was autogenerated by Pancake.',
    ];
  }
}

/**
 * External API for generating a comment from a PR stack
 *
 * const body = StackCommentBody.generate(context: TContext, prs: Array<PR>)
 * const withPointer = body.forPR(pr: PR);
 *
 */
export class StackCommentBody extends StackCommentBodyBase {
  public static generate(context: TContext, prs: Array<PR>): StackCommentBody {
    return new this(context, prs);
  }

  public forPR(pr: PR): string {
    return this.buildTreeComment(pr).join('\n');
  }
}
